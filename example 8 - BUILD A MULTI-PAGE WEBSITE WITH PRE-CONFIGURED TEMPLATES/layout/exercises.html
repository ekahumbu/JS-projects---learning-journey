<span class="dtext"> 
    <div id="exercise1"></div> 
    <h2>Exercise 1</h2> 
    <p>
        The trick is to create a table that tallies the appearance of each character as we loop through the string. 
        This table can be created using an object literal where the characters are keys and the counters are values. 
        Then, we can iterate through the table to find the character that has the largest counter by keeping temporary 
        variables for its key and value.
    </p> 
    <br> 
    <a href="#menu">Back To Top</a> <br> 
    <div id="exercise2"></div> 
    <h2>Exercise 2</h2> 
    <p>
        The key insight here is to realize that we can build on what 
        learned from the previous problem. Except, we need to return a boolean value. 
        This is as simple as returning a triple equality check against the original string. 
        We could also use the new every method on an array to check that the first and last characters match up in 
        sequential order towards the center. However, this will check two times more than necessary. 
        Similar to the previous problem, the runtime complexities for both time and space are identical.
    </p> 
    <br> 
    <a href="#menu">Back To Top</a> <br> 
    <div id="exercise3"></div> 
    <h2>Exercise 3</h2> 
    <p>
        In this section, we will walk through 22 commonly-asked algorithm questions in order of difficulty. 
        Alternate approaches will be discussed as well their tradeoffs and runtime complexities. 
        Usually, the most elegant solution utilizes a special “trick” or key insight. With this in mind, lets begin!
    </p> 
    <br> 
    <a href="#menu">Back To Top</a> 
    <br> 
    <div id="exercise4"></div> 
    <h2>Exercise 4</h2>
    <p>
        To assist in the calculus of runtime complexities, we approximate the scalability of an algorithm by extrapolating its input sizes 
        toward infinity before counting the number of operations required. At this worst-case runtime upper bound, 
        we can drop coefficients and additive terms, retaining only factors that dominate the function.
         Consequently, just a few categories can describe the scalability of almost any algorithm.  
    </p> <br> 
    <a href="#menu">Back To Top</a> <br> 
    <div id="exercise5"></div> 
    <h2>Exercise 5</h2> 
    <p>
        The cleanest algorithm usually takes advantage of standard objects inherent in the language. 
        Arguably the most important in computer science is Arrays. 
        In JavaScript, no other object has more utility methods than arrays. 
        Array methods worth remembering are: sort, reverse, slice, and splice. 
        Array elements are inserted beginning at the 0th index. 
        This means the last element is at array.length — 1. 
    </p>    
    <a href="#menu">Back To Top</a> <br> 
</span>